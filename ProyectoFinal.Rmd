---
title: "Proyecto Final"
author: "Sandra Patricia Cala Díaz"
output:   
  html_document:
    toc: true
    toc_float: true
    css: resource/styleRMD.css
---

# Expresiones regulares

Algunos sitios web dedicados a la explicación del uso de las expresiones regulares coinciden en que su uso no es muy frecuente, sin embargo en el mundo de la programación a menudo nos enfrentamos a problemas que requieren el uso de expresiones regulares. A continuación se realizará una comparación entre dos sitios web que hablan sobre las expresiones regulares.
<br><br>

* [Introducing Regular Expressions by Michael Fitzgerald](https://www.oreilly.com/library/view/introducing-regular-expressions/9781449338879/ch01.html)

  En la primera parte, este sitio web se dedica a explicar el problema inicial por el que surgieron las expresiones regulares, lo cual es un aspecto importante, ya que nos lleva a entender mejor el uso de ellas y en que casos se pueden usar. 

  Posteriormente hacen la introducción a otro sitio web donde se pueden probar las expresiones regulares (seguramente con la intención de que el lector pruebe allí las expresiones regulares de los próximos ejemplos), y después explica a través de ejemplos prácticos algunos usos de las expresiones regulares.

  Al final de los ejemplos más complejos realizan una lista con los símbolos utilizados en la creación de la expresión regular y el porqué fue utilizado en la expresión regular, lo que funciona como base si se piensa crear una expresión regular que aunque se parezca a algún ejemplo es muy específica. 

  Por último terminan indicando aplicaciones en donde se pueden utilizar expresiones regulares para realizar búsquedas, acción que realizamos con frecuencia, pero no la imaginamos con expresiones regulares.
<br><br>

* [Guía para entender y usar expresiones regulares](https://www.adictosaltrabajo.com/2015/01/29/regexsam/)

  Inicialmente este sitio web relata algunos ejemplos prácticos en los que se necesita el uso de expresiones regulares, con el fin de que el lector se contextualice y entienda en que casos puede usar las expresiones regulares.

  A continuación muestra listas sobre la sintaxis de las expresiones regulares y hace un corto resumen con los símbolos más utilizados en la creación de expresiones regulares.

  Posteriormente realiza una serie de ejemplos muy sencillos con los que abarca una parte importante de los símbolos de las expresiones regulares, lo que hace que el lector se familiarice entendiendo con ejemplos prácticos el uso de cada símbolo.

  Al finalizar da algunos tips que pueden ser importantes para quien se enfrenta a la creación de una expresión regular muy específica.

<br><br>
Los dos sitos web aciertan en dar una introducción al lector sobre en que casos se pueden utilizar expresiones regulares. En los ejemplos, el primer sitio web realiza de forma narrativa la descripción de la expresión regular, mientras que el segundo sitio web realiza una lista con un paso a paso en la construcción de expresiones regulares más complejas. Por último ambos sitios web complementan la guía con elementos de utilidad para quien está aprendiendo expresiones regulares.

# Comparación Markdown


# Estudio descriptivo

Para realizar el estudio descriptivo se utilizó la **API** _Actividades Culturales y de Ocio Municipal en los próximos 100 días_ disponible en el [Portal de datos abiertos del ayuntamiento de Madrid](https://datos.madrid.es/portal/site/egob). Una vez obtenidos los datos, se realizaron los siguientes pasos:

1. Tomar únicamente los datos de la respuesta del _request_.
2. Transformar de formato _JSON_ a _dataset_.
3. Llenar un _dataframe_ con los datos obtenidos.

```{r setup, include=FALSE}
library(httr)
library(rjson)
library(plyr) 
library(reshape2)
library(dplyr)
install.packages("formattable")
library(formattable)
library(tidyr)
library(ggplot2)
library(leaflet)
library(magrittr)
library(htmltools)


# Obtener datos haciendo petición a la API
url <- "https://datos.madrid.es/egob/catalogo/206974-0-agenda-eventos-culturales-100.json"
request.api <- GET(url)

# Hacer la transformación de la respuesta a dataframe
response.api <- content(request.api, as = "text", encoding = "UTF-8")
response.data <- fromJSON(response.api)
schedule.data <- do.call("rbind.fill", lapply(response.data$'@graph', as.data.frame))

# Cambiar valores 0 y 1 por gratis y de pago
schedule.data[schedule.data$price == 0, "price"] <- "Gratis"
schedule.data[schedule.data$price == 1, "price"] <- "De pago"

# Crear nueva columna con intervalo número de días del evento
schedule.data['number.days'] = as.Date(schedule.data$dtend, "%Y-%m-%d") - as.Date(schedule.data$dtstart, "%Y-%m-%d")
schedule.data.madrid <- mutate( schedule.data, 
                                interval.number.days = case_when(number.days == 0 ~ "1 día",
                                                       between(number.days, 2, 30) ~ "Menos de un mes",
                                                       between(number.days, 31, 90) ~ "Entre uno y tres meses",
                                                       between(number.days, 91, 180) ~ "Entre tres y seis meses",
                                                       between(number.days, 181, 365) ~ "Entre seis meses y un año",                                                        number.days > 366 ~ "Más de un año")) 

# Seleccionar datos que se van a usar
schedule.data.madrid <- select(schedule.data.madrid,
                              price, interval.number.days, audience, recurrence.days,
                              location = event.location,
                              longitude = location.longitude,
                              latitude = location.latitude)

```

Igualmente se realizaron otras transformaciones para el tratamiento de los datos, como la creación de un intervalo de duración activa de los eventos en Madrid, con lo que se pudo agrupar los eventos dependiendo de su duración. 


```{r schedule.data.madrid, echo=FALSE}
# Tabla
schedule.data.madrid.na <- schedule.data.madrid[!is.na(schedule.data.madrid$interval.number.days),]
table_by_interval <- ddply(schedule.data.madrid.na, .(interval.number.days), nrow) %>% arrange(desc(V1)) %>% rename('Duración' = interval.number.days, 'Número de eventos' = V1)
formattable(table_by_interval)
```

La tabla anterior muestra que la mayoria de los eventos en Madrid para los próximos 100 días son eventos de un solo día y en menor cantidad le siguen los eventos que duran activos entre dos días y más de un año.


## Eventos de pago vs. eventos gratuitos

Otro aspecto interesante de analizar, fue la cantidad de eventos de pago vs. la cantidad de eventos gratuitos, agrupados igualmente por la duración activa de los eventos.

```{r schedule.ggplot.madrid, echo=FALSE, message=FALSE}
# Gráfica ggplot
table_by_price <- ddply(schedule.data.madrid.na, .(price, interval.number.days), nrow) 
duration_order <- c("1 día", "Menos de un mes", "Entre uno y tres meses", "Entre tres y seis meses", "Entre seis meses y un año", "Más de un año")

graphic.schedule <- ggplot(table_by_price, aes(x = interval.number.days, y = V1))

graphic.schedule + geom_point(color='blue') + geom_line() + theme_linedraw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(x = "Duración") + labs(y = "Número de eventos") +
  scale_y_continuous(trans='log2') + scale_x_discrete(limits = duration_order) +
  facet_grid(~ price)

```

En la gráfica anterior se observa que los eventos de pago y gratuitos tienen un comportamiento similar, decreciendo para eventos activos de más de un día y siendo los eventos de un día los de mayor cantidad en ambos casos. Sin embargo los eventos de pago de un día superan con amplio margen los eventos gratuitos de un día.

## Mapa de los eventos en Madrid

Los datos obtenidos también incluian la ubicación y nombre del lugar donde se realiza cada evento, por lo que se creo un mapa para visualizar donde se realizan los eventos, con el respectivo nombre del lugar.

```{r schedule.ggmap.madrid, echo=FALSE,  warning=FALSE}
# Mapa
leaflet() %>% addTiles() %>% 
  addMarkers(data = schedule.data.madrid,
             lat = ~latitude, lng = ~longitude,
             label = ~htmlEscape(location), 
             clusterOptions = markerClusterOptions())

```

